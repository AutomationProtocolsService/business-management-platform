1 Â· Catch the real exception (so you stop getting the anonymous 503)
a. Add a global Express error handler
js
Copy
Edit
// index.js, **after** all routes
app.use((err, req, res, next) => {
  console.error('ğŸ’¥  Unhandled error', err);
  res.status(500).json({ error: err.message, stack: err.stack });
});
b. Instrument the route
js
Copy
Edit
router.post('/', async (req, res, next) => {
  console.log('â–¶ï¸  /installations hit with', req.body);    // ğŸ‘ˆ
  try {
    // â€¦ your logic â€¦
  } catch (err) {
    console.error('ğŸ›‘  Failed in /installations', err);      // ğŸ‘ˆ
    next(err);                                              // bubbles to handler above
  }
});
Now reload, click Schedule Installation once, and read the Console.
If you still get only â€œ503â€ with no server log, your server never received the requestâ€”jump to Â§ 5.

2 Â· Validate the POST payload before touching DB
Most â€œinstallation failsâ€ boil down to missing / invalid fields that blow up in your Prisma/ORM layer.

js
Copy
Edit
const z = require('zod');

const InstallationSchema = z.object({
  projectId: z.number().int().positive(),
  startTime: z.string().datetime(),
  endTime: z.string().datetime(),
  teamId: z.number().int().optional(),
  status: z.enum(['Scheduled', 'In Progress', 'Completed']),
  notes: z.string().optional()
});

router.post('/', async (req, res, next) => {
  try {
    const data = InstallationSchema.parse(req.body);  // throws 400 on bad input
    // â€¦ create in DB â€¦
  } catch (err) {
    if (err instanceof z.ZodError) {
      return res.status(400).json({ error: err.errors });
    }
    next(err);
  }
});
Why?
The â€œNo team members availableâ€ message in your form suggests teamId might be null.
If your DB column is NOT NULL, Prisma will reject, throw, and youâ€™ll bail with a 503.

3 Â· Eliminate database connectivity issues
Credentials present?
Replit â–¸ Secrets panel must contain the exact env vars your DB client expects.

Run a health query at startup

js
Copy
Edit
import pkg from '@prisma/client';
const { PrismaClient } = pkg;
const db = new PrismaClient();

db.$queryRaw`SELECT 1`            // pings the DB
  .then(() => console.log('âœ…  DB up'))
  .catch(err => {
    console.error('â›”ï¸  DB unreachable', err);
    process.exit(1);              // fail fast
  });
Check connection pool limits (Supabase â‰ˆ 20).
On Replit free plans your app sleeps; when it wakes every Post request creates a new connection.
Either await db.$disconnect() when idle or use a singleton database client.

4 Â· Confirm the request even hits your server
Open DevTools â–¸ Network and inspect the failing entry:

What to look at	What it tells you
Initiator	â€œfetchâ€ âŸ¶ your React code fired it.
â€œ(prefetch)â€ or missing âŸ¶ maybe not.
Remote Addr	Should be your repl domain. If itâ€™s 34.117.** it already routed to Replit proxy.
Response Headers	If server: nginx/1.15 â†’ Replit proxy emitted 503 (server didnâ€™t answer).
If itâ€™s your own Express headers (x-powered-by: Express) â†’ the bug is in your code.

You can also hit the endpoint directly from Replitâ€™s shell:

bash
Copy
Edit
curl -v -X POST $REPLIT_URL/api/installations -H 'Content-Type: application/json' \
  -d '{"projectId":1,"startTime":"2025-06-17T19:57:00Z","endTime":"2025-06-26T21:57:00Z","status":"In Progress"}'
If the curl also returns 503 â†’ server or proxy issue.

If curl succeeds â†’ bug is in the React fetch (wrong origin, missing credentials, etc.)

5 Â· Make sure youâ€™re listening on the correct $PORT
Replit injects a random port into process.env.PORT.
Hard-coding 3000 or 5000 will work locally but break in prod.

js
Copy
Edit
const PORT = process.env.PORT || 3000;   // local fallback
app.listen(PORT, () => console.log('Server up on', PORT));
Re-deploy, then reconfirm with lsof -i -P -n | grep LISTEN.

6 Â· Kill zombie processes that hog the port
Sometimes a crash leaves Node running; Replit spawns a second instance that canâ€™t bind and exits quickly, so the proxy shows 503.

bash
Copy
Edit
ps aux | grep node          # multiple Node PIDs?
kill -9 <pid>
npm start
Add nodemon.json to auto-restart cleanly:

json
Copy
Edit
{
  "execMap": { "js": "node --exit-code 1" },
  "watch": ["src"],
  "ext": "js,json"
}
7 Â· Double-check CORS & SameSite cookies
If you see two network rowsâ€”a pre-flight OPTIONS that gets 503, then the POST never firesâ€”your CORS middleware is mis-configured.

js
Copy
Edit
app.use(require('cors')({
  origin: '*',              // tighten later
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
8 Â· Guard against out-of-memory / long-running tasks
Replit free instances get ~512 MiB. A runaway PDF generator or huge query may SIGKILL the process mid-request:

Stream large responses (res.write) instead of buffering.

Offload heavy work to a background job (e.g. Supabase Edge Function).

9 Â· Deploy a /healthz route for quick detective work
js
Copy
Edit
app.get('/healthz', (req, res) => res.json({ up: true, time: Date.now() }));
If curl /healthz sometimes fails, the problem is with uptime / crashes, not your installations route.

10 Â· Still stuck? Flip the stack to â€œserverlessâ€
Comment this out

js
Copy
Edit
app.use('/api/installations', installationsRouter);
Replace with a Supabase Function / Vercel Edge Function:

js
Copy
Edit
export default async (req, res) => {
  // same logic, but runs on demand, no port needed
}
If that works, the issue was Replit process management; migrate permanently or upgrade to Replitâ€™s paid â€œReserved VMâ€ plan for stability.

â¬¢ TL;DR Flowchart
Does /installations log hit?
No âŸ¶ check proxy/port (Â§ 5-6).
Yes âŸ¶ what does the stack trace say? (Â§ 1-3).

No stack trace? Enable global handler.

Stack trace = DB error? Fix schema/connection.

Stack trace = validation error? Zod + return 400.

Everything looks right locally but 503 on Replit?
Port, OOM, or zombie processâ€”see Â§ 5-6-8.