1) Verify your form structure and event wiring
Make sure all of your <input>, <Select>, <Checkbox>, and the submit <Button> live inside the same <form> block. If your button is outside, the browser wonâ€™t call onSubmit.

Wrap your dialogâ€™s content like so:

tsx
Copy
Edit
export function ExpenseFormDialog({ open, onOpenChange }: { open: boolean; onOpenChange: (o: boolean) => void }) {
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const createExpense = useMutation(/* â€¦ as above â€¦ */);

  const [formState, setFormState] = useState({ /* your fields */ });

  // a simple submit handler
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log("ğŸ”” form submitted!", formState);
    createExpense.mutate(formState);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-h-[80vh] overflow-auto">
        <DialogHeader>
          <DialogTitle>Add Expense</DialogTitle>
        </DialogHeader>
        {/* <-- THE FORM STARTS HERE */}
        <form onSubmit={handleSubmit}>
          {/* All your form controls MUST be inside this <form> */}
          <div className="grid gap-4">
            <Input
              label="Amount"
              type="number"
              value={formState.amount}
              onValueChange={(amount) =>
                setFormState((s) => ({ ...s, amount }))
              }
              required
            />
            <Input
              label="Date"
              type="date"
              value={formState.date}
              onChange={(e) =>
                setFormState((s) => ({ ...s, date: e.target.value }))
              }
              required
            />

            {/* â€¦ your other inputs here â€¦ */}

            <Checkbox
              label="Reimbursable"
              checked={formState.reimbursable}
              onCheckedChange={(val) =>
                setFormState((s) => ({ ...s, reimbursable: !!val }))
              }
            />
          </div>

          {/* <-- THE BUTTON IS INSIDE THE FORM */}
          <div className="mt-6 flex justify-end gap-2">
            <Button
              variant="secondary"
              onClick={() => onOpenChange(false)}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={createExpense.isLoading}>
              {createExpense.isLoading ? "Creatingâ€¦" : "Create Expense"}
            </Button>
          </div>
        </form>
        {/* <-- THE FORM ENDS HERE */}
      </DialogContent>
    </Dialog>
  );
}
Checklist
âœ… Single <form> tag wrapping all fields and the submit button

âœ… Button has type="submit" (not just an onClick)

âœ… Your <DialogContent> uses overflow-auto (so the scroll bar works, and the button is reachable)

2) Add debug logs
In your handleSubmit add a console.log("ğŸ”” form submitted", formState).

In your mutationâ€™s onMutate, log the payload:

ts
Copy
Edit
const createExpense = useMutation(
  async (payload) => { /*â€¦*/ },
  {
    onMutate(payload) {
      console.log("ğŸš€ creating expense with", payload);
    },
    onSuccess: () => { /*â€¦*/ },
    onError: (err) => { /*â€¦*/ },
  }
);
Then:

Open DevTools â†’ Console

Click â€œCreate Expenseâ€ â†’ you should see â€œğŸ”” form submittedâ€ and â€œğŸš€ creating expenseâ€¦â€

If you donâ€™t see those:

Your formâ€™s onSubmit isnâ€™t wired correctly

Or the button is outside the form

Or a parent element (e.g. the dialog) is intercepting clicks (check CSS pointer-events)

3) Verify the network call
Once your console logs fire, switch to the Network tab:

Click your submit button

Make sure you see a POST /api/expenses request

It should return 201 and the response JSON

If the network call never happens, we know the problem is entirely front-end wiring. If it does happen but the dialog never closes:

Ensure you call onOpenChange(false) in your mutationâ€™s onSuccess:

ts
Copy
Edit
onSuccess() {
  toast({ title: "Expense created!", variant: "success" });
  queryClient.invalidateQueries(["expenses"]);
  onOpenChange(false); // <â€” closes the modal
}
TL;DR
Wrap all your inputs and the â€œCreate Expenseâ€ button in one <form onSubmit={â€¦}>.

Make the button type="submit".

Add console logs in your submit handler and mutationâ€™s onMutate.

Confirm you see those logs, then confirm the POST in Network.

On success, close the modal and invalidate your query.

That pattern always worksâ€”once your logs land, youâ€™re done. Let me know which of those logs never appears and weâ€™ll dig deeper!